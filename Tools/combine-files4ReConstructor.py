
import os
import sys

"""
The Context Consolidator (The "ReConstructor")

Purpose:
This script builds the "Boot Disk" for your AI. It reads the list of files
generated by `list_project_tree.py` and combines their contents into a single
Markdown file (`RECONSTRUCTOR_CONTEXT.md`).

Why do we need this?
AI Context Windows are limited. Pasting files one by one is slow and error-prone.
This script formats everything into a standardized block that the AI can ingest
instantly to understand the entire project state.

Usage:
python Tools/combine-files4ReConstructor.py
"""

def get_project_name_from_repo_root(repo_root_path):
    """
    Attempts to guess the project name from the folder name.
    Used for the file headers.
    """
    try:
        project_name = os.path.basename(repo_root_path)
        if project_name:
            return project_name
    except Exception:
        pass
    return "AI-Assisted-Student-Project"

def create_consolidated_context(file_list_path, output_file_path):
    """
    Reads a list of files and consolidates them into a single Markdown file
    with headers/footers for AI ingestion.
    """
    print(f"Starting ReConstructor context consolidation...")
    print(f"Reading file list from: {file_list_path}")

    try:
        # Read the list of files to process
        with open(file_list_path, 'r', encoding='utf-8') as f:
            # Filter out empty lines and comments
            file_paths = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]

        if not file_paths:
            print("ERROR: No file paths found in the list.")
            return

        # Determine the project root (assumes script is run from root)
        repo_root = os.getcwd()
        project_name = get_project_name_from_repo_root(repo_root)

        with open(output_file_path, 'w', encoding='utf-8') as outfile:
            for file_path in file_paths:
                # Construct absolute path
                full_file_path = os.path.join(repo_root, file_path)
                
                # Standardize path for the AI header (always use forward slashes)
                header_path = file_path.replace(os.sep, '/')
                if not header_path.startswith('/'):
                    header_path = '/' + header_path

                try:
                    with open(full_file_path, 'r', encoding='utf-8') as infile:
                        content = infile.read()

                        # --- The Standard Serializable Format ---
                        # 1. The Header (AI identifies the file start here)
                        outfile.write(f"# Project: {project_name}; File: {header_path}\n\n")
                        
                        # 2. The Content
                        outfile.write(content)
                        
                        # 3. The Footer (AI identifies the file end here)
                        outfile.write(f"\n\n---[END OF FILE: {header_path}]---\n\n")
                        
                        print(f"Processed: {file_path}")

                except FileNotFoundError:
                    print(f"WARNING: File listed in text file but not found on disk: {file_path}")
                except Exception as e:
                    print(f"ERROR processing file {file_path}: {e}")

        print(f"\nSuccess! Context created at: {output_file_path}")
        print("You can now copy the content of this file and paste it to your AI.")

    except FileNotFoundError:
        print(f"CRITICAL ERROR: Could not find file list '{file_list_path}'")
        print("Did you run 'list_project_tree.py' first?")

if __name__ == "__main__":
    # Default file names
    FILE_LIST = 'reconstructor-file-list.txt'
    OUTPUT_FILE = 'RECONSTRUCTOR_CONTEXT.md'
    
    # Allow overriding via command line arguments
    if len(sys.argv) > 1:
        FILE_LIST = sys.argv[1]

    create_consolidated_context(FILE_LIST, OUTPUT_FILE)